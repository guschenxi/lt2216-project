{"version":3,"sources":["chartparser.js","runparser.js","grammars/appoint.ts","dmAppointment.ts","index.tsx","srgs.js"],"names":["LOG","str","clone","obj","temp","constructor","key","isEmpty","ob","i","hasOwnProperty","Chart","numberOfWords","this","passives","Array","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","content","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","_string","toString","ActiveEdge","rest","rules","text","parse","words","grammar","root","filter","$root","chart","agenda","leftCornerFilter","addToChart","inference","rhs","slice","SRGS","min","max","oneof","eval","undefined","ruleref","position","leftCorners","pop","active","join","ref","passive","loadGrammar","dom","DOMParser","parseFromString","ActiveXObject","doc","XML","newDocument","loadXML","url","encodeURIComponent","request","XMLHttpRequest","open","send","responseXML","parseXML","getElementsByTagName","getAttribute","xrules","r","xrule","processRuleExpansions","xitems","childNodes","rule","nodeType","textContent","trim","split","nodeName","uri","repeat","parseInt","Infinity","console","log","actions","cancel","gram","yesnogram","prs_grammar","input","result","say","_context","type","value","listen","delay","id","Timer","initial","states","welcome","prompt","entry","who","on","RECOGNISED","context","recResult","ENDSPEECH","ask","nomatch","commands","assign","count","person","day","whole_day","yesnoanswer","time","replace","confirm","hour","minute","ampm","inspect","iframe","machine","Machine","dm","init","CLICK","asrtts","idle","LISTEN","SPEAK","target","event","ttsAgenda","recognising","exit","ASRRESULT","MAXSPEECH","match","speaking","recLogResult","test","logIntent","nluData","intent","name","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","lang","recStop","changeColour","document","body","background","ttsStart","effect","u","SpeechSynthesisUtterance","speechSynthesis","ttsCancel","current","onClick","rootElement","getElementById","ReactDOM","Grammar","VOID","OneOf","NULL","GARBAGE","$check","checkSequenceExpansion","err","throwRuleError","Ref","RefClass","Tag","tag","TagClass","alternatives","OneOfClass","Repeat","sequence","RepeatClass","message","error","TypeError","String","checkExpansion","prototype","Number"],"mappings":"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","file":"static/js/main.26386d8e.chunk.js","sourcesContent":["//\n//  chartparser.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* Mods by Torbjörn\n- Removed the toString() method from Object. Why does it still work?\n- Added a text variable (similar to rules). See \n*/\n\n//////////////////////////////////////////////////////////////////////\n// a logging function\n//  - uncomment if you want to debug the parsing process\nfunction LOG(str) {\n  //console.log(\"\" + str);\n}\n\nimport * as SRGS from './srgs'\n\n//////////////////////////////////////////////////////////////////////\n// we need to be able to clone objects between different edges\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\nfunction clone(obj){\n  if (obj == null || typeof(obj) != 'object') {\n    return obj;\n  }\n  var temp = new obj.constructor(); \n  for (var key in obj) {\n    temp[key] = clone(obj[key]);\n  }\n  return temp;\n}\n\n\nfunction isEmpty(ob){\n   for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\n  return true;\n}\n\n//////////////////////////////////////////////////////////////////////\n// parse chart\n// conceptually this is a set of edges, but it is optimized\nfunction Chart(numberOfWords) {\n  this.numberOfWords = numberOfWords;\n  this.passives = new Array(numberOfWords);\n  this.actives = new Array(numberOfWords);\n  for (var i = 0; i <= numberOfWords; i++) {\n    this.passives[i] = {};\n    this.actives[i] = {};\n  }\n\n  // Chart.add(edge)\n  // add the edge to the chart, return true if the chart was changed \n  // (i.e. if the chart didn't already contain the edge)\n  this.add = function add(edge) {\n    var subchart, cat;\n    if (edge.isPassive) {\n      subchart = this.passives[edge.start];\n      cat = edge.lhs;\n    } else {\n      subchart = this.actives[edge.end];\n      cat = edge.next.content;\n    }\n    if (!(cat in subchart)) {\n      subchart[cat] = {};\n    }\n    if (edge in subchart[cat]) {\n      return false;\n    } else {\n      subchart[cat][edge] = edge;\n      return true;\n    }\n  }\n\n  // Chart.resultsForRule(lhs, start, end)\n  // return all parse results for the given lhs, start, and end\n  //  - start, end are optional; defaults to 0, numberOfWords\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\n    start = start || 0;\n    end = end || numberOfWords;\n    var results = [];\n    var finalEdges = this.passives[start][lhs];\n    for (var i in finalEdges) {\n      if (finalEdges[i].end == end) {\n\tresults.push(finalEdges[i].out);\n      }\n    }\n    return results;\n  }\n  \n  // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\n  // return an array of all (passive/active) edges in the chart\n  this.allEdges = function allEdges() {\n    return this.allPassiveEdges().concat(this.allActiveEdges());\n  }\n  this.allPassiveEdges = function allPassiveEdges() {\n    var edges = [];\n    for (var i in this.passives) \n      for (var j in this.passives[i]) \n\tfor (var k in this.passives[i][j])\n\t  edges.push(this.passives[i][j][k]);\n    return edges;\n  }\n  this.allActiveEdges = function allActiveEdges() {\n    var edges = [];\n    for (var i in this.actives) \n      for (var j in this.actives[i]) \n\tfor (var k in this.actives[i][j])\n\t  edges.push(this.actives[i][j][k]);\n    return edges;\n  }\n\n  // Chart.statistics()\n  // return the number of edges in the chart\n  this.statistics = function statistics() {\n    var passives = this.allPassiveEdges().length;\n    var actives = this.allActiveEdges().length;\n    return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// parse edges: passive and active\n\nfunction PassiveEdge(start, end, lhs, out) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.out = out;\n  this.isPassive = true;\n\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.next = next;\n  this.rest = rest;\n  this.out = out;\n  this.rules = rules;\n  this.text = text;\n  this.isPassive = false;\n\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \n    \", \" + rest + \" := \" + out + \" <- \" + rules;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// the main parsing function: a simple top-down chartparser\n//  - 'words' is an array of strings\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\n//  - 'root' is the starting category (a string)\n//    if unspecified, use the '$root' property of the grammar\n//  - 'filter' is an optional left-corner filter \n//    (a mapping from categories/rule-refs to words)\n//    if specified, it is used when predicting new edges\n// returns the final chart\nexport function parse(words, grammar, root, filter) {\n  if (!root) {\n    root = grammar.$root;\n  }\n  var chart = new Chart(words.length);\n  var agenda = [];\n\n  var leftCornerFilter;\n  if (filter == undefined) {\n    leftCornerFilter = function() {return true};\n  } else {\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\n      var leftCorners = filter[ruleref];\n      return leftCorners ? words[position] in leftCorners : true;\n    }\n  }\n  \n  // add an edge to the chart and the agenda, if it does not already exist\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\n    var edge;\n    if (rhs.length > 0) {\n      var next = rhs[0];\n      var rest = rhs.slice(1);\n      switch (next.constructor) {\n\t\n      case Array:\n\t// the next symbol is a sequence\n\taddToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\n\treturn;\n\t\n      case SRGS.RepeatClass:\n\t// the next symbol is a repetition\n\tvar min = next.min;\n\tvar max = next.max;\n\t// skip repeat \n\tif (min <= 0) {\n\t  addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\n\t}\n\t// repeat \n\tif (max > 0) {\n\t  var content = next.content;\n\t  var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\n\t  addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\n\t}\n\treturn;\n\t\n      case SRGS.OneOfClass:\n\t// the next symbol is a disjunction\n\tvar oneof = next.content;\n\tfor (var i in oneof) {\n\t  var rhs = oneof[i].concat(rest);\n\t  addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\n\t} \n\treturn;\n\t\n      case SRGS.TagClass:\n\t// the next symbol is a semantic action\n\tout = clone(out);\n\trules = clone(rules);\n\teval(next.content);\n\taddToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\n\treturn;\n      }\n\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\n    } else {\n      edge = new PassiveEdge(start, end, lhs, out);\n    }\n    \n    // try to add the edge; if successful, also add it to the agenda\n    if (chart.add(edge)) {\n      LOG(\"+ \" + inference + \": \" + edge);\n      agenda.push(edge);\n    }\n  }\n  \n  // seed the agenda with the starting rule\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\n  \n  // main loop\n  while (agenda.length > 0) {\n    var edge = agenda.pop();\n    var start= edge.start;\n    var end  = edge.end;\n    var lhs  = edge.lhs;\n    var next = edge.next;\n    LOG(edge);\n\n    if (edge.isPassive) {\n      // combine\n      var actives = chart.actives[start][lhs];\n      for (var i in actives) {\n\tvar active = actives[i];\n\tvar rules = clone(active.rules);\n\tvar text = active.text;\n\ttext[edge.lhs] = words.slice(start, end).join(\" \");\n\tif (typeof edge.out == 'object' && isEmpty(edge.out)) {\n\t    rules[edge.lhs] = text[edge.lhs];\n\t} else {\n        rules[edge.lhs] = clone(edge.out);\n    }\n\taddToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\n      }\n\n    } else if (next.constructor == SRGS.RefClass) {\n      var ref = next.content;\n      // combine\n      var passives = chart.passives[end][ref];\n      for (var i in passives) {\n\tvar passive = passives[i];\n\tvar rules = clone(edge.rules);\n\tvar text = edge.text;\n\trules[passive.lhs] = clone(passive.out);\n\ttext[passive.lhs] = passive.text;\n\taddToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\n      }\n      // predict\n      if (ref in grammar) {\n\tif (leftCornerFilter(ref, end)) {\n\t  addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\n\t}\n      }\n\n    } else if (next == words[end]) {\n      // scan\n      addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\n    }\n  }\n\n  return chart;\n}\n\n\n","//\n//  runparser.js\n//\n/*\n  The author or authors of this code dedicate any and all \n  copyright interest in this code to the public domain.\n*/\n\n\n// helper functions for the parser demo\n\nimport * as SRGS from './srgs'\n\nfunction getElement(id) {\n  return document.getElementById(id);\n}\n\nfunction appendElement(parent, element, text) {\n  var elem = document.createElement(element);\n  if (text)\n    elem.appendChild(document.createTextNode(text));\n  parent.appendChild(elem);\n  return elem\n}\n\nfunction runParser(input) {\n  var resultsDiv = getElement(\"results\");\n  resultsDiv.innerHTML = \"\";\n  var maybeFilter;\n  if (getElement(\"usefilter\") && getElement(\"usefilter\").checked) {\n    maybeFilter = filter;\n    appendElement(resultsDiv, \"EM\", \"Using left-corner filter\");\n  }\n  var startTime = new Date();\n  var parseChart = parse(input, grammar, grammar.$root, maybeFilter);\n  var parseTime = new Date() - startTime;\n  var parseResults = parseChart.resultsForRule(grammar.$root);\n  \n  console.log(parseResults[0]);\n  \n  if (parseResults) {\n    for (var i in parseResults) {\n        resultsDiv.innerHTML += display(parseResults[i],\"\");\n    }\n  } else {\n    appendElement(resultsDiv, \"P\", \"No results found!\");\n  }\n  \n/*\n  if (parseResults) { \n    var resultList = appendElement(resultsDiv, \"OL\");\n    for (var i in parseResults) \n      appendElement(resultList, \"LI\", JSON.stringify(parseResults[i]));\n  } else {\n    appendElement(resultsDiv, \"P\", \"No results found!\");\n  }\n*/\n  var statistics = parseChart.statistics()\n  appendElement(resultsDiv, \"P\", \"Chart size: \" + statistics.nrEdges + \" edges\" +\n\t\t\" (\" + statistics.nrPassiveEdges + \" passive)\");\n  appendElement(resultsDiv, \"P\", \"Parse time: \" + parseTime + \" ms\" + \n\t\t\" (\" + (parseTime / statistics.nrEdges).toFixed(2) + \" ms/edge)\");\n}\n\nfunction runWordParser() {\n  runParser(getElement(\"input\").value.split(/\\s+/));\n}\n\nfunction runCharacterParser() {\n  runParser(getElement(\"input\").value.split(\"\"));\n}\n\nexport function loadGrammar(str) {\n    var dom = parseXML(str);\n    var root = dom.getElementsByTagName(\"grammar\")[0].getAttribute(\"root\");\n    var grammar = new SRGS.Grammar(root);\n    var xrules = dom.getElementsByTagName(\"rule\");\n    for(var r=0; r < xrules.length; r++) {\n        var xrule = xrules[r];\n        var id = xrule.getAttribute(\"id\");\n        grammar[id] = processRuleExpansions(xrule);\n    }\n    return grammar;\n}\n\nfunction processRuleExpansions(xrule) {\n    var xitems = xrule.childNodes;\n    var rule = [];\n    for(var i=0; i < xitems.length; i++) {\n        if (xitems[i].nodeType == 3) {\n            var str = xitems[i].textContent.trim();\n            if (str != \"\") {\n                rule.push(str.split(/ +/));\n            }\n        } else if (xitems[i].nodeType == 1) {\n            if (xitems[i].nodeName == \"token\") {\n                rule.push(SRGS.Tag(xitems[i].textContent));\n            } else if (xitems[i].nodeName == \"ruleref\") {\n                var uri = xitems[i].getAttribute(\"uri\");\n                rule.push(SRGS.Ref(uri.slice(1)));\n            } else if (xitems[i].nodeName == \"tag\") {\n                rule.push(SRGS.Tag(xitems[i].textContent.trim()));\n            } else if (xitems[i].nodeName == \"one-of\") {\n                rule.push(SRGS.OneOf(processRuleExpansions(xitems[i])));\n            } else if (xitems[i].nodeName == \"item\") {\n                var repeat = xitems[i].getAttribute(\"repeat\");\n                if (!repeat) {\n                    rule.push(processRuleExpansions(xitems[i]));\n                } else {\n                    var r = repeat.split(\"-\");\n                    var min = parseInt(r[0]);\n                    var max = parseInt(r[1]);\n                    max = (max) ? max : Infinity;\n                    rule.push(SRGS.Repeat(min, max, processRuleExpansions(xitems[i])));\n                }\n            } else {\n                console.log(xitems[i]);\n            }\n        }\n    }\n\treturn rule;\n}\n\nfunction parseXML(text) {\n    if (typeof DOMParser != \"undefined\") {\n        // Mozilla, Firefox, and related browsers\n        return (new DOMParser()).parseFromString(text, \"application/xml\");\n    }\n    else if (typeof ActiveXObject != \"undefined\") {\n        // Internet Explorer.\n        var doc = XML.newDocument();  // Create an empty document\n        doc.loadXML(text);            // Parse text into it\n        return doc;                   // Return it\n    }\n    else {\n        // As a last resort, try loading the document from a data: URL\n        // This is supposed to work in Safari. Thanks to Manos Batsis and\n        // his Sarissa library (sarissa.sourceforge.net) for this technique.\n        var url = \"data:text/xml;charset=utf-8,\" + encodeURIComponent(text);\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", url, false);\n        request.send(null);\n        return request.responseXML;\n    }\n};\n","export const grammar = `\n<grammar root=\"final\">\n   <rule id=\"final\">\n      <tag>out = new Object(); </tag>\n      <ruleref uri=\"#opening\"/>\n         <item repeat=\"1-3\">\n             <one-of>\n                <item><ruleref uri=\"#person\"/><tag>out.person = rules.person;</tag></item>\n                <item><ruleref uri=\"#day\"/><tag>out.day = rules.day;</tag></item>\n                <item><ruleref uri=\"#time\"/><tag>out.time = rules.time;</tag></item>\n             </one-of>\n         </item>\n   </rule>\n   <rule id=\"person\">\n      <item repeat=\"0-1\">with</item>\n      <one-of> \n         <item> David <tag> out = 'David Svensson'; </tag></item>\n         <item> Monica <tag> out = 'Monica Johansson'; </tag></item>\n         <item> Sven <tag> out = 'Sven Svala'; </tag></item>\n         <item> Jack <tag> out = 'Jack Chen'; </tag></item>\n      </one-of>\n   </rule>\n   <rule id=\"day\">\n      <item repeat=\"0-1\">on</item><item repeat=\"0-1\">the</item>\n      <one-of> \n         <item> Monday <tag> out = 'Monday'; </tag></item>\n         <item> Tuesday <tag> out = 'Tuesday'; </tag></item>\n         <item> Wednesday <tag> out = 'Wednesday'; </tag></item>\n         <item> Thursday <tag> out = 'Thursday'; </tag></item>\n         <item> Friday <tag> out = 'Friday'; </tag></item>\n         <item> Saturday <tag> out = 'Saturday'; </tag></item>\n         <item> Sunday <tag> out = 'Sunday'; </tag></item>\n      </one-of>\n   </rule>\n   <rule id=\"time\">\n      <tag> out.ampm = \" \"; </tag>\n      <item repeat=\"0-1\"> at </item>\n      <one-of>\n         <item><ruleref uri=\"#hour\"/><tag>out.hour = rules.hour; out.minute = \"00\"</tag></item>\n         <item><ruleref uri=\"#hour\"/>:00<tag>out.hour = rules.hour; out.minute = \"00\"</tag></item>\n         <item><ruleref uri=\"#hour\"/>:<ruleref uri=\"#minute\"/><tag>out.hour = rules.hour; out.minute = rules.minute;</tag></item>\n         <item><ruleref uri=\"#minute\"/><tag> out.minute = rules.minute; </tag> past <ruleref uri=\"#hour\"/><tag>out.hour = rules.hour; </tag></item>\n         <item><ruleref uri=\"#minute\"/><tag> out.minute = 60 - rules.minute; </tag> to <ruleref uri=\"#hour\"/><tag>out.hour = rules.hour - 1; </tag></item>\n      </one-of>\n      <item repeat=\"0-1\"> o'clock </item>\n      <item repeat=\"0-1\">\n          <one-of>\n              <item>a.m.<tag> out.ampm = \"a.m.\"; </tag></item>\n              <item>p.m.<tag> out.ampm = \"p.m.\"; </tag></item>\n          </one-of>\n       </item>\n   </rule>\n   <rule id=\"minute\">\n      <one-of>\n         <item><item repeat = \"1-2\"><one-of><item>0</item><item>o</item></one-of></item> <tag> out = '00'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>1 <tag> out = '01'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>2 <tag> out = '02'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>3 <tag> out = '03'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>4 <tag> out = '04'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>5 <tag> out = '05'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>6 <tag> out = '06'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>7 <tag> out = '07'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>8 <tag> out = '08'; </tag></item>\n         <item><item repeat = \"0-1\"><one-of><item>0</item><item>o</item></one-of></item>9 <tag> out = '09'; </tag></item>\n         <item>10 <tag> out = '10'; </tag></item>\n         <item>11<tag> out = '11'; </tag></item>\n         <item>12 <tag> out = '12'; </tag></item>\n         <item>13 <tag> out = '13'; </tag></item>\n         <item>14 <tag> out = '14'; </tag></item>\n         <item><one-of><item>15 </item><item><item repeat=\"0-1\">a</item>quarter</item></one-of> <tag> out = '15'; </tag></item>\n         <item>16 <tag> out = '16'; </tag></item>\n         <item>17 <tag> out = '17'; </tag></item>\n         <item>18 <tag> out = '18'; </tag></item>\n         <item>19 <tag> out = '19'; </tag></item>\n         <item>20 <tag> out = '20'; </tag></item>\n         <item>21 <tag> out = '21'; </tag></item>\n         <item>22 <tag> out = '22'; </tag></item>\n         <item>23 <tag> out = '23'; </tag></item>\n         <item>24 <tag> out = '24'; </tag></item>\n         <item>25 <tag> out = '25'; </tag></item>\n         <item>26 <tag> out = '26'; </tag></item>\n         <item>27 <tag> out = '27'; </tag></item>\n         <item>28 <tag> out = '28'; </tag></item>\n         <item>29 <tag> out = '29'; </tag></item>\n         <item><one-of><item>30 </item><item>half </item></one-of><tag> out = '30'; </tag></item>\n         <item>31 <tag> out = '31'; </tag></item>\n         <item>32 <tag> out = '32'; </tag></item>\n         <item>33 <tag> out = '33'; </tag></item>\n         <item>34 <tag> out = '34'; </tag></item>\n         <item>35 <tag> out = '35'; </tag></item>\n         <item>36 <tag> out = '36'; </tag></item>\n         <item>37 <tag> out = '37'; </tag></item>\n         <item>38 <tag> out = '38'; </tag></item>\n         <item>39 <tag> out = '39'; </tag></item>\n         <item>40 <tag> out = '40'; </tag></item>\n         <item>41 <tag> out = '41'; </tag></item>\n         <item>42 <tag> out = '42'; </tag></item>\n         <item>43 <tag> out = '43'; </tag></item>\n         <item>44 <tag> out = '44'; </tag></item>\n         <item>45 <tag> out = '45'; </tag></item>\n         <item>46 <tag> out = '46'; </tag></item>\n         <item>47 <tag> out = '47'; </tag></item>\n         <item>48 <tag> out = '48'; </tag></item>\n         <item>49 <tag> out = '49'; </tag></item>\n         <item>50 <tag> out = '50'; </tag></item>\n         <item>51 <tag> out = '51'; </tag></item>\n         <item>52 <tag> out = '52'; </tag></item>\n         <item>53 <tag> out = '53'; </tag></item>\n         <item>54 <tag> out = '54'; </tag></item>\n         <item>55 <tag> out = '55'; </tag></item>\n         <item>56 <tag> out = '56'; </tag></item>\n         <item>57 <tag> out = '57'; </tag></item>\n         <item>58 <tag> out = '58'; </tag></item>\n         <item>59 <tag> out = '59'; </tag></item>\n         <item>60 <tag> out = '60'; </tag></item>\n      </one-of>\n   </rule>\n   <rule id=\"hour\">\n      <one-of>\n         <item><item repeat = \"0-1\">zero</item> 1 <tag> out = '1'; </tag></item>\n         <item><item repeat = \"0-1\">zero</item> 2 <tag> out = '2'; </tag></item>\n         <item><item repeat = \"0-1\">zero</item> 3 <tag> out = '3'; </tag></item>\n         <item><item repeat = \"0-1\">zero</item> 4 <tag> out = '4'; </tag></item>\n         <item><item repeat = \"0-1\">zero</item> 5 <tag> out = '5'; </tag></item>\n         <item><item repeat = \"0-1\">zero</item> 6 <tag> out = '6'; </tag></item>\n         <item><item repeat = \"0-1\">zero</item> 7 <tag> out = '7'; </tag></item>\n         <item><item repeat = \"0-1\">zero</item> 8 <tag> out = '8'; </tag></item>\n         <item><item repeat = \"0-1\">zero</item> 9 <tag> out = '9'; </tag></item>\n         <item>10 <tag> out = '10'; </tag></item>\n         <item>11<tag> out = '11'; </tag></item>\n         <item>12 <tag> out = '12'; </tag></item>\n         <item>13 <tag> out = '13'; </tag></item>\n         <item>14 <tag> out = '14'; </tag></item>\n         <item>15 <tag> out = '15'; </tag></item>\n         <item>16 <tag> out = '16'; </tag></item>\n         <item>17 <tag> out = '17'; </tag></item>\n         <item>18 <tag> out = '18'; </tag></item>\n         <item>19 <tag> out = '19'; </tag></item>\n         <item>20 <tag> out = '20'; </tag></item>\n         <item>21 <tag> out = '21'; </tag></item>\n         <item>22 <tag> out = '22'; </tag></item>\n         <item>23 <tag> out = '23'; </tag></item>\n         <item>24 <tag> out = '24'; </tag></item>\n      </one-of>\n   </rule>\n  \n   <rule id=\"opening\">\n      <item repeat=\"0-1\">\n         <one-of>\n            <item>meeting</item>\n            <item>meeting with</item>\n            <item>create a meeting </item>\n            <item>create an appointment</item>\n            <item>appointment</item>\n         </one-of>\n      </item>\n   </rule>\n</grammar>\n`\nexport const yesnogrammar = `\n<grammar root=\"final\">\n   <rule id=\"final\">\n         <tag>out = new Object();</tag>\n         <item repeat=\"1-2\">\n             <one-of>\n                <item><ruleref uri=\"#yes\"/><tag>out.yesnoanswer = rules.yes;</tag></item>\n                <item><ruleref uri=\"#no\"/><tag>out.yesnoanswer = rules.no;</tag></item>\n             </one-of>\n         </item>\n   </rule>\n   <rule id=\"yes\">\n      <tag> out = true; </tag>\n      <one-of> \n         <item> yes </item>\n         <item> of course </item>\n         <item> absolutely </item>\n         <item> right </item>\n         <item> that's right </item>\n         <item> confirm </item>\n      </one-of>\n   </rule>\n   <rule id=\"no\">\n      <tag> out = false; </tag>\n      <one-of> \n         <item> no </item>\n         <item> no way </item>\n         <item> absolutely not </item>\n         <item> no no </item>\n      </one-of>\n   </rule>\n</grammar>\n`\n","import { MachineConfig, actions, Action, assign } from \"xstate\";\nconst { send, cancel } = actions;\nimport { loadGrammar } from './runparser';\nimport { parse } from './chartparser';\nimport { grammar, yesnogrammar } from './grammars/appoint';\n\nconst gram = loadGrammar(grammar);\nconst yesnogram = loadGrammar(yesnogrammar);\n\nfunction prs_grammar(input: string, grammar) {\n  console.log(input)\n  var prs = parse(input.split(/\\s+/), grammar);\n  var result = prs.resultsForRule(gram.$root);\n  console.log(result);\n  return result[0];\n}\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return [send(\"LISTEN\"), send('MAXSPEECH', {delay: 6000, id:'maxsp'}) ]\n}\n\n\nexport const Timer: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'who',\n    id: \"Timer\",\n    states: {\n        welcome: {\n            initial: \"prompt\",\n            states: {\n                prompt: { entry: say(\"Hej, Välkommen hit! \") }\n            }\n        },\n\twho: {\n\t    initial: \"prompt\",\n\t    on: {\n\t        RECOGNISED: (context)=> say(context.recResult)\n            },\n\t    states: {\n\t        prompt: {\n                    entry: send((context) => ({\n\t                type: \"SPEAK\",\n\t                value: 'Hej, vem ska du se? 你好！Hello!'\n\t            })),\n\t            on: { ENDSPEECH: \"ask\"}\n\t        },\n\t        ask: {\n\t            entry: listen()\n\t        },\n\t        nomatch: {\n\t            entry: say(\"Sorry I don't know them. Say for example Monica\"),\n\t            on: { ENDSPEECH: \"prompt\" }\n\t        }\n\t    }\n\t},\n    }\n})\n\n\nconst commands=[\"stop\",\"start over\",\"help\",\"go back\"];\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = (\n{\n    initial: 'main_function',\n    id: \"appointmentMachine\",\n    states: {\n      \thist: {\n            type: \"history\",\n            history: \"shallow\",\n            //target: \"main_function\",\n        },\n\n        startover: {\n            entry: say(\"Ok. starting over.\"),\n            on: { ENDSPEECH: \"main_function\" }\n        },\n\n        stop: {\n            entry: say(\"Going back to the root menu.\"),\n            always: '#root'\n        },\n/*\n        goback: {\n            entry: say(\"Going back to the previous step.\"),\n            always: '#main.hist'\n        },\n*/\n        help: {\n            entry: say(\"I can't help you at the moment. Going back to the previous step.\"),\n            on: {'ENDSPEECH': '#main.hist'}\n        },\n\n        maxspeech: {\n            entry: [say(\"timeout. say help if you need personal help\"), assign((context) => { return { count: context.count + 1 } }), (context) => console.log(\"Reprompt : \" + (4 - context.count) )],\n            on: {\n                'ENDSPEECH': [\n                    {actions: [assign((context) => { return { count: 0 } }), \n                               send((context) => ({type: \"SPEAK\", value: 'Sorry. Going back to the root menu now.'}))],\n\t             target: '#root', cond: (context) => context.count === 4},\n                    {target: '#main.hist'},\n                ]\n            }\n        },\n\n        main_function: {\n            initial: \"welcome\",\n            id: \"main\",\n            on: {\n                RECOGNISED: [\n                   { target: '#appointmentMachine.stop', cond: (context) => context.recResult === 'stop' },\n                   //{ target: '#appointmentMachine.goback', cond: (context) => context.recResult === 'go back' },\n\t           { target: '#appointmentMachine.help', cond: (context) => context.recResult === 'help' },\n                   { target: '#appointmentMachine.startover', cond: (context) => context.recResult === 'start over' }\n                ],\n                MAXSPEECH: \"#appointmentMachine.maxspeech\",\n            },\n            states:{\n      \t        hist: {\n                    type: \"history\",\n                    history: \"shallow\",\n                    target: \"#main\",\n                },\n        \twelcome: {\n                    initial: \"prompt\",\n \t            on: { ENDSPEECH: \"who\" },\n        \t    states: {\n        \t        prompt: { entry: say(\"Let's create an appointment\") }\n        \t    }\n        \t},\n\n        \twho: {\n        \t    initial: \"prompt\",\n        \t    on: {\n        \t        RECOGNISED: [\n                        {\n        \t            cond: (context) => \"person\" in (prs_grammar(context.recResult, gram) || {}),\n        \t            actions: [assign((context) => { return { person: prs_grammar(context.recResult, gram).person } }), cancel('maxsp')],\n        \t            target: \"day\"\n        \t        },\n        \t        { target: \".nomatch\", cond: (context) => !(commands.includes(context.recResult)) }],\n                    },\n        \t    states: {\n        \t        prompt: {\n                            entry: send((context) => ({\n        \t                type: \"SPEAK\",\n        \t                value: 'Who are you meeting with?'\n        \t            })),\n        \t            on: { ENDSPEECH: \"ask\"}\n        \t        },\n        \t        ask: {\n        \t            entry: listen()\n        \t        },\n        \t        nomatch: {\n        \t            entry: say(\"Sorry I don't know them. Say for example Monica\"),\n        \t            on: { ENDSPEECH: \"prompt\" }\n        \t        }\n        \t    }\n        \t},\n        \tday: {\n        \t    initial: \"repeat\",\n        \t    on: {\n        \t        RECOGNISED: [\n        \t        {\n        \t            cond: (context) => \"day\" in (prs_grammar(context.recResult, gram) || {}),\n        \t            actions: [assign((context) => { return { day: prs_grammar(context.recResult, gram).day } }),cancel('maxsp')],\n        \t            target: \"whole_day\"\n        \t        },\n        \t        { target: \".nomatch\", cond: (context) => !(commands.includes(context.recResult)),}]\n        \t    },\n        \t    states: {\n        \t        repeat: {\n        \t            entry: send((context) => ({\n        \t                type: \"SPEAK\",\n        \t                value: `OK. Meeting with ${context.person}.`\n        \t            })),\n        \t            on: { ENDSPEECH: \"prompt\" }\n        \t        },\n        \t        prompt: {\n        \t            entry: send((context) => ({\n        \t                type: \"SPEAK\",\n        \t                value: \" On which day is your meeting? \"\n        \t            })),\n        \t            on: { ENDSPEECH: \"ask\" }\n        \t        },\n        \t        ask: {\n        \t            entry: listen()\n        \t        },\n        \t        nomatch: {\n        \t            entry: say(\"Sorry I don't understand which day you mean. Say for example on Tuesday\"),\n        \t            on: { ENDSPEECH: \"prompt\" }\n        \t        }\n        \t    }\n        \t},\n        \twhole_day: {\n        \t    initial: \"repeat\",\n        \t    on: {\n        \t        RECOGNISED: [\n        \t        {\n        \t            cond: (context) => \"yesnoanswer\" in (prs_grammar(context.recResult, yesnogram) || {}),\n        \t            actions: [assign((context) => { return { whole_day: prs_grammar(context.recResult, yesnogram).yesnoanswer } }), cancel('maxsp')],\n        \t            target: \".choose\"\n        \t        },\n        \t        { target: \".nomatch\", cond: (context) => !(commands.includes(context.recResult)) }]\n        \t    },\n        \t    states: {\n        \t        repeat: {\n        \t            entry: send((context) => ({\n        \t                type: \"SPEAK\",\n        \t                value: `OK. Meeting with ${context.person} on ${context.day}.`\n        \t            })),\n        \t            on: { ENDSPEECH: \"prompt\" }\n        \t        },\n        \t        prompt: {\n        \t            entry: send((context) => ({\n        \t                type: \"SPEAK\",\n        \t                value: \" Will it take the whole day?\"\n        \t            })),\n        \t            on: { ENDSPEECH: \"ask\" }\n        \t        },\n        \t        ask: {\n        \t            entry: listen()\n        \t        },\n        \t        choose: {\n        \t              always:[\n        \t                     {target: '#main.time', cond: (context) => context.whole_day === false},\t\n        \t                     {target: '#main.confirm_without_time'}] \n        \t        },\n        \t        nomatch: {\n        \t            entry: say(\"Sorry I don't understand. Say yes or no.\"),\n        \t            on: { ENDSPEECH: \"prompt\" }\n        \t        }\n        \t    }\n        \t},\n        \ttime: {\n        \t    initial: \"repeat\",\n        \t    on: {\n        \t        RECOGNISED: [\n        \t        {\n        \t            cond: (context) => \"time\" in (prs_grammar(context.recResult.replace(':', ' : '), gram) || {}),\t\n        \t            actions: [assign((context) => { return { time: prs_grammar(context.recResult.replace(':',' : '), gram).time } }), cancel('maxsp')],\n        \t            target: \"confirm_with_time\"\n        \t        },\n        \t        { target: \".nomatch\", cond: (context) => !(commands.includes(context.recResult)) }]\n        \t    },\n        \t    states: {\n        \t        repeat: {\n        \t            entry: send((context) => ({\n        \t                type: \"SPEAK\",\n        \t                value: `OK. `\n        \t            })),\n        \t            on: { ENDSPEECH: \"prompt\" }\n        \t        },\n        \t        prompt: {\n        \t            entry: send((context) => ({\n        \t                type: \"SPEAK\",\n        \t                value: `What time is your meeting?`\n        \t            })),\n        \t            on: { ENDSPEECH: \"ask\" }\n        \t        },\n        \t        ask: {\n        \t            entry: listen()\n        \t        },\n        \t        nomatch: {\n        \t            entry: say(\"Sorry I don't understand which time you mean. Say for example at eleven\"),\n        \t            on: { ENDSPEECH: \"prompt\" }\n        \t        }\n        \t    }\n        \t},\n        \tconfirm_without_time: {\n        \t    initial: \"prompt\",\n        \t    on: {\n        \t        RECOGNISED: [\n        \t        {\n        \t            cond: (context) => \"yesnoanswer\" in (prs_grammar(context.recResult, yesnogram) || {}),\n        \t            actions: [assign((context) => { return { confirm: prs_grammar(context.recResult, yesnogram).yesnoanswer } }), cancel('maxsp')],\n        \t            target: \".choose\"\n        \t        },\n        \t        { target: \".nomatch\", cond: (context) => !(commands.includes(context.recResult)) }]\n\t            },\n\t            states: {\n\t                prompt: {\n\t                    entry: send((context) => ({\n\t                        type: \"SPEAK\",\n\t                        value: `Do you want me to creat an appointment with ${context.person} on ${context.day} for the whole day?`\n\t                    })),\n        \t            on: { ENDSPEECH: \"ask\" }\n\t                },\n\t                ask: {\n\t                    entry: listen()\n\t                },\n\t                choose: {\n\t                      always: [\n\t                             {target: '#main.final', cond: (context) => context.confirm === true },\n\t                             {target: '#main.who', cond: (context) => context.confirm === false }\n\t                            ] \n\t                },\n\t                nomatch: {\n\t                    entry: say(\"Sorry I don't understand. Say yes or no.\"),\n\t                    on: { ENDSPEECH: \"prompt\" }\n\t                }\n\t            }\n\t        },\n\t        confirm_with_time: {\n\t            initial: \"prompt\",\n\t            on: {\n        \t        RECOGNISED: [\n        \t        {\n        \t            cond: (context) => \"yesnoanswer\" in (prs_grammar(context.recResult, yesnogram) || {}),\n        \t            actions: [assign((context) => { return { confirm: prs_grammar(context.recResult, yesnogram).yesnoanswer } }), cancel('maxsp')],\n        \t            target: \".choose\"\n        \t        },\n        \t        { target: \".nomatch\", cond: (context) => !(commands.includes(context.recResult)) }]\n        \t    },\n        \t    states: {\n        \t        prompt: {\n        \t            entry: send((context) => ({\n        \t                type: \"SPEAK\",\n        \t                value: `Do you want me to creat an appointment with ${context.person} on ${context.day} at ${context.time.hour}:${context.time.minute} ${context.time.ampm}?`\n        \t            })),\n        \t            on: { ENDSPEECH: \"ask\" }\n        \t        },\n        \t        ask: {\n        \t            entry: listen()\n        \t        },\n        \t        choose: {\n        \t              always:  [\n        \t                     {target: '#main.final', cond: (context) => context.confirm === true },\n                \t             {target: '#main.who', cond: (context) => context.confirm === false }\n                \t            ] \n                \t},\n                \tnomatch: {\n                \t    entry: say(\"Sorry I don't understand. Say yes or no.\"),\n                \t    on: { ENDSPEECH: \"prompt\" }\n                \t}\n           \t     }\t\n        \t},\n       \t        final: {\n         \t    initial: \"prompt\",\n       \t            states: {\n        \t        prompt: { \n              \t            type: \"final\",\n                \t    entry: say(\"Your appointment has been created! Going back to the root menu now.\"),\n                            on : { ENDSPEECH: \"#root\"} \n\t\t\t}\n            \t    }\n        \t}\n\t    }\n        }\n    },\n}\n/*{\n    guards: {\n      isNotCommand: (context) => !(commands.includes(context.recResult)),\n      isPersonGrammar: (context) => \"person\" in (prs_grammar(context.recResult, gram) || {}),\n      isDayGrammar: (context) => \"day\" in (prs_grammar(context.recResult, gram) || {}),\n      isTimeGrammar: (context) => \"time\" in (prs_grammar(context.recResult.replace(':', ' : '), gram) || {}),\n      isYesNoGrammar: (context) => \"yesnoanswer\" in (prs_grammar(context.recResult, yesnogram) || {}),\n      \n    }\n}*/\n)\n\n\nexport const TODOitem: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'welcome',\n    id: \"TODOitem\",\n    states: {\n        welcome: {\n            initial: \"prompt\",\n            states: {\n                prompt: { entry: say(\"Choose an item to do.\") }\n            }\n        },\n    }\n})\n\n\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, send, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMachine, TODOitem, Timer } from \"./dmAppointment\";\nimport { IntentMachine } from \"./dmIntent\";\nimport { SmartHomeMachine } from \"./dmSmartHome\";\n\n\n\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\n\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    context: {count : 0},\n    states: {\n        dm: {\n          initial: 'init',\n          id: \"main\",\n          states:{\n              init: {on: {CLICK: '#root.dm.Timer'}\n              //init: {on: {CLICK: 'IntentMachine'}\n        },\n                //IntentMachine: {...IntentMachine},\n                //dmAppointment: {...dmMachine},\n                //TODOitem: {...SmartHomeMachine}, // smarthome\n                Timer: {...Timer},\n            }\n\n\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    }\n                },\n                recognising: {\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: {\n                            actions: assign((context) => { return { count: 0 } }),\n                            target:'idle'\n                        },\n                        MAXSPEECH: 'idle',\n                    },\n                    states: {\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive a input.');\n                listen({\n                    interimResults: false,\n                    continuous: true,\n                    lang: \"sv-SE\",\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            changeColour: asEffect((context) => {\n                console.log('Repainting...');\n                document.body.style.background = context.recResult;\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda, lang: \"en-UK\" });\n                  var u = new SpeechSynthesisUtterance();\n                  u.text = context.ttsAgenda;\n                  u.lang = 'sv-SE';\n                console.log(u)\n                speechSynthesis.speak(u);\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            })\n            /* speak: asEffect((context) => {\n\t     * console.log('Speaking...');\n             *     speak({text: context.ttsAgenda })\n             * } */\n        }\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\n\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://lt2216-a2.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'http://maraev.me' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n\n\n\n","//\n//  srgs.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n//////////////////////////////////////////////////////////////////////\n// encoding SRGS grammars in javascript\n\nexport function Grammar(root) {\n  this.$root = root;\n  \n  this.VOID = [OneOf([])];\n  this.NULL = [];\n  this.GARBAGE = []; \n  \n  this.$check = function() {\n    for (var i in this) {\n      if (i !== \"$root\" && i !== \"$check\") {\n\ttry {\n\t  checkSequenceExpansion(this[i]);\n\t} catch(err) {\n\t  throwRuleError(\"When checking grammar rule '\" + i + \"'\", err);\n\t}\n      }\n    }\n  }\n}\n\nexport function WordSet(str) {\n  var words = str.split(/ +/);\n  var set = {};\n  for (var i in words) {\n    set[words[i]] = true;\n  }\n  return set;\n}\n\n//////////////////////////////////////////////////////////////////////\n// rule expansion constructors\n\n// sequences are ordinary arrays\nexport function Sequence(seq) {\n  return seq;\n}\n\nexport function Ref(ref) {\n  return new RefClass(ref);\n}\n\nexport function Tag(tag) {\n  return new TagClass(tag);\n}\n\nexport function OneOf(alternatives) {\n  return new OneOfClass(alternatives);\n}\n\nexport function Repeat(min, max, sequence) {\n  return new RepeatClass(min, max, sequence);\n}\n\nexport function Optional(sequence) {\n  return new RepeatClass(0, 1, sequence);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rule expansion classes\n\nexport function RefClass(ruleref) {\n  this.content = ruleref;\n  this._string = \"$\" + ruleref;\n  this.toString = function toString() {return this._string}\n}\n    \nexport function TagClass(tag) {\n  this.content = tag;\n  this._string = \"{\" + tag + \"}\";\n  this.toString = function toString() {return this._string}\n}\n\nexport function OneOfClass(alternatives) {\n  this.content = alternatives;\n  this._string = \"(\" + alternatives.join(\"|\") + \")\";\n  this.toString = function toString() {return this._string}\n}\n\nexport function RepeatClass(min, max, sequence) {\n  this.min = min;\n  this.max = max;\n  this.content = sequence;\n  this._string = this.content + \"<\" + this.min + \"-\" + (this.max==Infinity ? \"\" : this.max) + \">\"\n  this.toString = function toString() {return this._string}\n}\n\n//////////////////////////////////////////////////////////////////////\n// checking rule expansions\n\nexport function throwRuleError(message, error) {\n  if (error == undefined) {\n    throw TypeError(message);\n  } else {\n    throw TypeError(message + \"; \" + error.message);\n  }\n}\n\nexport function checkSequenceExpansion(sequence) {\n  try {\n    if (sequence.constructor !== Array) {\n      throwRuleError(\"Expected Array, found \" + sequence.constructor.name);\n    }\n    for (var i in sequence) {\n      if (sequence[i].constructor == Array) {\n\tcheckSequenceExpansion(sequence[i]);\n      } else if (sequence[i].constructor != String) {\n\tsequence[i].checkExpansion();\n      }\n    }\n  } catch(err) {\n    throwRuleError(\"When checking sequence expansion\", err);\n  }\n};\n\nRefClass.prototype.checkExpansion = function checkExpansion() {\n  if (this.content.constructor !== String) {\n    throwRuleError(\"When checking Ref content; Expected String, found \" + this.content.constructor.name);\n  }\n};\n\nTagClass.prototype.checkExpansion = function checkExpansion() {\n  if (this.content.constructor !== String) {\n      throwRuleError(\"When checking Tag content; Expected String, found \" + this.content.constructor.name);\n  }\n};\n\nOneOfClass.prototype.checkExpansion = function checkExpansion() {\n  try {\n    if (this.content.constructor !== Array) {\n      throwRuleError(\"Expected Array, found \" + this.content.constructor.name);\n    }\n    for (var i in this.content) {\n      checkSequenceExpansion(this.content[i]);\n    }\n  } catch(err) {\n    throwRuleError(\"When checking OneOf content\", err);\n  }\n};\n\nRepeatClass.prototype.checkExpansion = function checkExpansion() {\n  try {\n    if (this.min.constructor !== Number || this.max.constructor !== Number) {\n      throwRuleError(\"Expected min/max to be Number, found \" + this.min.constructor.name + \"/\" + this.max.constructor.name);\n    }\n    if (!(0 <= this.min && this.min <= this.max)) {\n      throwRuleError(\"Expected 0 <= min <= max, found \" + this.min + \"/\" + this.max);\n    }\n    checkSequenceExpansion(this.content);\n  } catch(err) {\n    throwRuleError(\"When checking Repeat content\", err);\n  }\n};\n\n"],"sourceRoot":""}